package de.meps.card;

import java.util.Iterator;

/**
 * A immutable high performance low memory set of card representation using bit
 * boards. Due a deck of cards only contains 52 cards each card is represented
 * by a single bit of a single <code>long</code> value.
 * 
 * Thereby all operation will run in constant time <b>O(1)</b> (only exception
 * is the {@link #filter(CardFilter)} operation with <b>O(n)</b>).
 * 
 * Due immutability all 'manipulating' method return new result sets as result
 * of their manipulation. The originating set left unchanged. This avoids any
 * side effects.
 * 
 * <h3>Board representation</h3>
 * 
 * A card board uses 52 of the possible 64 bits. It is ordered primary by rank,
 * secondary by suit like shown here:
 * 
 * <pre>
 * AAAA KKKK QQQQ JJJJ TTTT 9999 8888 7777 6666 5555 4444 3333 2222
 * ♠♥♦♣ ♠♥♦♣ ♠♥♦♣ ♠♥♦♣ ♠♥♦♣ ♠♥♦♣ ♠♥♦♣ ♠♥♦♣ ♠♥♦♣ ♠♥♦♣ ♠♥♦♣ ♠♥♦♣ ♠♥♦♣
 * </pre>
 * 
 * Aces assigned to the 4 most left significant (used) bits, 2th to the most
 * right least significant (used) bits. Thereby a simple hand rating is
 * possible. High numeric <code>long</code> values mean there are some high
 * ranked cards in there.
 * 
 * @author jan
 * 
 */
public final class CardSet implements Iterable<Card> {

	/**
	 * Lowest to highest card.
	 * 
	 * @author jan
	 * 
	 */
	private final class CardSetIterator implements Iterator<Card> {

		private long board = cardBoard;
		private int index = 1;

		@Override
		public boolean hasNext() {
			return board > 0L;
		}

		@Override
		public Card next() {
			while (hasNext() && (board & 1L) == 0) {
				inc();
			}
			Card res = CARDS[index];
			inc();
			return res;
		}

		@Override
		public void remove() {
			throw new UnsupportedOperationException("CardSets are immutable!");
		}

		private void inc() {
			index++;
			board >>>= 1;
		}
	}

	public final static CardSet EMPTY = new CardSet(0L);

	private final static long[] SUIT_BOARDS = makeSuitBoards();
	private final static long[] RANK_BOARDS = makeRankBoards();
	private final static Card[] CARDS = makeCardIndex();
	private final static int[] CONNECTIONS = makeConnectionRankMap();

	private final static long CLUBS = SUIT_BOARDS[Suit.CLUBS.ordinal()];
	private final static long DIAMONDS = SUIT_BOARDS[Suit.DIAMONDS.ordinal()];
	private final static long HEARTS = SUIT_BOARDS[Suit.HEARTS.ordinal()];
	private final static long SPADES = SUIT_BOARDS[Suit.SPADES.ordinal()];
	private final static long BOARD_MASK = HEARTS | CLUBS | SPADES | DIAMONDS;

	private static long boardOf(Card card) {
		return boardOf(card.suit(), card.rank());
	}

	private static long boardOf(Suit suit, Rank rank) {
		return singleBitAt(indexOf(suit, rank));
	}

	private static int indexOf(Card card) {
		return indexOf(card.suit(), card.rank());
	}

	private static int indexOf(Suit suit, Rank rank) {
		return (rank.ordinal() * 4) + suit.ordinal();
	}

	private static int indexOfHighestBoardCard(long board) {
		return 64 - Long.numberOfLeadingZeros(board);
	}

	private static int indexOfLowestBoardCard(long board) {
		return Math.min(63, Long.numberOfTrailingZeros(board) + 1);
	}

	private static Card[] makeCardIndex() {
		Card[] cards = new Card[64];
		for (Suit suit : Suit.values()) {
			for (Card card : suit) {
				cards[indexOf(card)] = card;
			}
		}
		return cards;
	}

	private static int[] makeConnectionRankMap() {
		int high = Rank.ACE.ordinal();
		int low = Rank._2.ordinal();
		int[] map = new int[high - low + 2];
		int j = 0;
		for (int i = high; i >= low; i--) {
			map[j++] = i;
		}
		map[j] = Rank.ACE.ordinal(); // wheel hands: 5-4-3-2-A
		return map;
	}

	private static long[] makeRankBoards() {
		Rank[] ranks = Rank.values();
		long[] masks = new long[ranks.length];
		for (int rank = Rank._2.ordinal(); rank <= Rank.ACE.ordinal(); rank++) {
			long rankMask = 0;
			for (Suit suit : Suit.values()) {
				rankMask |= boardOf(suit, ranks[rank]);
			}
			masks[rank] = rankMask;
		}
		return masks;
	}

	private static long[] makeSuitBoards() {
		Suit[] suits = Suit.values();
		long[] masks = new long[suits.length];
		for (Suit suit : suits) {
			final int i = suit.ordinal();
			for (Card card : suit) {
				masks[i] |= boardOf(card);
			}
		}
		return masks;
	}

	private static CardSet setOf(long cardsBoard) {
		return cardsBoard == 0L
			? EMPTY
			: new CardSet(cardsBoard);
	}

	private static long singleBitAt(int bitIndex) {
		--bitIndex;
		return (bitIndex > 31)
			? ((1L << 32) << (bitIndex % 32))
			: (1L << bitIndex);
	}

	private static long singleBitAtHighestCardOfBoard(long board) {
		return singleBitAt(indexOfHighestBoardCard(board));
	}

	private final long cardBoard;

	private CardSet(long cardsBoard) {
		this.cardBoard = cardsBoard;
	}

	public boolean allOf(CardSet other) {
		return isSubset(other);
	}

	public boolean allOf(Rank rank) {
		return atLeastNOfBoard(RANK_BOARDS[rank.ordinal()], 4);
	}

	public boolean allOf(Suit suit) {
		return atLeastNOfBoard(SUIT_BOARDS[suit.ordinal()], 13);
	}

	public boolean anyOf(CardSet other) {
		return anyOfBoard(other.cardBoard);
	}

	public boolean anyOf(Rank rank) {
		return anyOfBoard(RANK_BOARDS[rank.ordinal()]);
	}

	public boolean anyOf(Suit suit) {
		return anyOfBoard(SUIT_BOARDS[suit.ordinal()]);
	}

	public int cardinality() {
		return Long.bitCount(cardBoard);
	}

	public CardSet complement() {
		return setOf((~cardBoard) & BOARD_MASK);
	}

	public int countConnected() {
		int count = 0;
		int actual = 0;
		for (int rankIndex : CONNECTIONS) {
			long rankBoard = RANK_BOARDS[rankIndex];
			if (anyOfBoard(rankBoard)) {
				++actual;
				count = Math.max(count, actual);
			} else {
				actual = 0;
			}
		}
		return count;
	}

	public int countSameKind(Rank rank) {
		return countCardsInBoard(RANK_BOARDS[rank.ordinal()]);
	}

	public int countSuited(Suit suit) {
		return countCardsInBoard(SUIT_BOARDS[suit.ordinal()]);
	}

	public boolean equals(CardSet other) {
		return cardBoard == other.cardBoard;
	}

	@Override
	public boolean equals(Object obj) {
		return obj instanceof CardSet && cardBoard == ((CardSet) obj).cardBoard;
	}

	public CardSet filter(CardFilter filter) {
		long resBoard = cardBoard;
		for (Card card : this) {
			if (!filter.accept(card)) {
				resBoard &= ~boardOf(card);
			}
		}
		return setOf(resBoard);
	}

	@Override
	public int hashCode() {
		return (int) cardBoard + (int) (cardBoard >> 32);
	}

	public Card highestCard() {
		return highestCardOfBoard(cardBoard);
	}

	public CardSet highestFlush() {
		return highestNFlush(5);
	}

	public CardSet highestFourOfAKind() {
		return highestNOfAKind(4);
	}

	public CardSet highestFullHouse() {
		CardSet threeOfAKind = highestThreeOfAKind();
		if (threeOfAKind == EMPTY)
			return EMPTY;
		CardSet pair = without(threeOfAKind).highestOnePair();
		if (pair == EMPTY)
			return EMPTY;
		return threeOfAKind.union(pair);
	}

	public CardSet highestNCards(int n) {
		return highestNCardsOfBoard(cardBoard, n);
	}

	public CardSet highestNFlush(int n) {
		for (long suitBoard : SUIT_BOARDS) {
			if (atLeastNOfBoard(suitBoard, n)) {
				return highestNCardsOfBoard(cardBoard & suitBoard, n);
			}
		}
		return EMPTY;
	}

	public CardSet highestNOfAKind(int n) {
		for (int i = Rank.ACE.ordinal(); i >= Rank._2.ordinal(); i--) {
			if (atLeastNOfBoard(RANK_BOARDS[i], n)) {
				return highestNCardsOfBoard(cardBoard & RANK_BOARDS[i], n);
			}
		}
		return EMPTY;
	}

	public CardSet highestNStraight(int n) {
		return highestNStraightOfBoard(cardBoard, n);
	}

	public CardSet highestNStraightFlush(int n) {
		for (long suitBoard : SUIT_BOARDS) {
			CardSet straightFlush = highestNStraightOfBoard(cardBoard
					& suitBoard, n);
			if (straightFlush != EMPTY)
				return straightFlush;
		}
		return EMPTY;
	}

	public CardSet highestOnePair() {
		return highestNOfAKind(2);
	}

	/**
	 * Will not remind that a straight flush is higher even if the cards used
	 * are lower than those of highest straight.
	 * 
	 * @see #highestStraightFlush()
	 */
	public CardSet highestStraight() {
		return highestNStraight(5);
	}

	public CardSet highestStraightFlush() {
		return highestNStraightFlush(5);
	}

	public CardSet highestThreeOfAKind() {
		return highestNOfAKind(3);
	}

	public CardSet highestTwoPair() {
		CardSet pair1 = highestOnePair();
		if (pair1 == EMPTY)
			return EMPTY;
		CardSet pair2 = without(pair1).highestOnePair();
		if (pair2 == EMPTY)
			return EMPTY;
		return pair1.union(pair2);
	}

	public CardSet intersection(CardSet with) {
		return setOf(cardBoard & with.cardBoard);
	}

	public boolean isEmpty() {
		return this == EMPTY;
	}

	public boolean isIn(Card card) {
		return anyOfBoard(boardOf(card));
	}

	public boolean isSubset(CardSet other) {
		return (cardBoard & other.cardBoard) == other.cardBoard;
	}

	@Override
	public Iterator<Card> iterator() {
		return new CardSetIterator();
	}

	public Card lowestCard() {
		return CARDS[indexOfLowestBoardCard(cardBoard)];
	}

	public int maxSameKind() {
		int max = 0;
		Rank[] ranks = Rank.values();
		for (int i = Rank._2.ordinal(); i <= Rank.ACE.ordinal(); i++) {
			max = Math.max(max, countSameKind(ranks[i]));
		}
		return max;
	}

	public int maxSuited() {
		int max = 0;
		for (Suit suit : Suit.values()) {
			max = Math.max(max, countSuited(suit));
		}
		return max;
	}

	public Card[] toArray() {
		return toArray(Order.ASCENDING);
	}

	public Card[] toArray(Order order) {
		Card[] res = new Card[cardinality()];
		if (order == Order.ASCENDING) {
			int i = 0;
			for (Card card : this) {
				res[i++] = card;
			}
		} else {
			int i = cardinality();
			for (Card card : this) {
				res[--i] = card;
			}
		}
		return res;
	}

	@Override
	public String toString() {
		if (isEmpty())
			return "";
		StringBuilder b = new StringBuilder();
		for (Card card : this) {
			b.append(' ');
			b.append(card);
		}
		return b.substring(1);
	}

	public CardSet union(CardSet with) {
		return setOf(cardBoard | with.cardBoard);
	}

	public CardSet with(Card card) {
		return setOf(cardBoard | boardOf(card));
	}

	public CardSet without(Card... cards) {
		if (cards == null || cards.length == 0)
			return this;
		long board = cardBoard;
		for (Card card : cards) {
			board &= ~boardOf(card);
		}
		return setOf(board);
	}

	public CardSet without(Card card) {
		return setOf(cardBoard & ~(boardOf(card)));
	}

	public CardSet without(CardSet that) {
		return setOf(cardBoard & ~that.cardBoard);
	}

	private boolean anyOfBoard(long board) {
		return (cardBoard & board) > 0L;
	}

	private boolean atLeastNOfBoard(long board, int n) {
		return Long.bitCount(cardBoard & board) >= n;
	}

	private int countCardsInBoard(long board) {
		return Long.bitCount(cardBoard & board);
	}

	private Card highestCardOfBoard(long board) {
		return CARDS[indexOfHighestBoardCard(board)];
	}

	private CardSet highestNCardsOfBoard(long board, int n) {
		long highestBoard = 0L;
		for (int i = 0; i < n; i++) {
			highestBoard |= singleBitAtHighestCardOfBoard(board & ~highestBoard);
		}
		return setOf(highestBoard);
	}

	private CardSet highestNStraightOfBoard(long board, int n) {
		int cardNr = 0;
		long straightBoard = 0L;
		for (int rankIndex : CONNECTIONS) {
			long rankBoard = RANK_BOARDS[rankIndex];
			if (anyOfBoard(rankBoard)) {
				if (cardNr == 0)
					straightBoard = 0L;
				cardNr++;
				straightBoard |= singleBitAtHighestCardOfBoard(cardBoard
						& rankBoard);
				if (cardNr == n) {
					return setOf(straightBoard);
				}
			} else {
				cardNr = 0;
			}
		}
		return EMPTY;
	}

}
